"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * screen-size-detector by Fakhzan
 * Licensed under MIT (https://github.com/devfakhzan/screen-size-detector)
 * --------------------------------------------------------------------------
 */
var ScreenSizeDetector =
/*#__PURE__*/
function () {
  function ScreenSizeDetector() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ScreenSizeDetector);

    var o = options; // User options validators

    if (o.onHeightChange && typeof o.onHeightChange !== "function") throw this._typeErrorMessageBuilder('"onHeightChange"', "function", o.onHeightChange);
    if (o.onWidthChange && typeof o.onWidthChange !== "function") throw this._typeErrorMessageBuilder('"onWidthChange"', "function", o.onWidthChange);
    if (o.onBothChange && typeof o.onBothChange !== "function") throw this._typeErrorMessageBuilder('"onBothChange"', "function", o.onBothChange);

    if (o.widthDefinitions && !this._isEmptyObject(o.widthDefinitions)) {
      this._validateWidthDefinition(o.widthDefinitions);
    }

    window.addEventListener("resize", function () {
      return _this._resizeHandler();
    });
    var defaultOptions = {
      onHeightChange: function onHeightChange() {},
      onWidthChange: function onWidthChange() {},
      onBothChange: function onBothChange() {},
      widthDefinitions: {
        smartwatch: {
          min: 0,
          max: 319,
          inclusion: "[]"
        },
        mobile: {
          min: 320,
          max: 480,
          inclusion: "[]"
        },
        tablet: {
          min: 481,
          max: 768,
          inclusion: "[]",
          onEnter: function onEnter() {},
          whileInside: function whileInside() {},
          onLeave: function onLeave() {}
        },
        laptop: {
          min: 769,
          max: 1024,
          inclusion: "[]"
        },
        desktop: {
          min: 1025,
          max: 1200,
          inclusion: "[]"
        },
        largedesktop: {
          min: 1201,
          max: Infinity,
          inclusion: "[]"
        }
      }
    }; // Create final options with defaultOptions as the base, merged/overwritten by user supplied 'options'

    if (o.widthDefinitions) {
      if (!this._isEmptyObject(o.widthDefinitions)) {
        defaultOptions.widthDefinitions = _objectSpread({}, defaultOptions.widthDefinitions, {}, o.widthDefinitions);
        delete o.widthDefinitions;
      } else {
        defaultOptions.widthDefinitions = {};
      }
    }

    var finalOptions = _objectSpread({}, defaultOptions, {}, o); // Set variables to class instance


    for (var _i = 0, _Object$entries = Object.entries(finalOptions); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      this[key] = value;
    }

    this.width = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
    this.height = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
    var isObj = {};
    Object.keys(this.widthDefinitions).forEach(function (key) {
      return isObj[key] = false;
    });
    this.is = isObj;

    this._computeIsAndCallbacks();
  }

  _createClass(ScreenSizeDetector, [{
    key: "_aOrAn",
    value: function _aOrAn(noun) {
      return ["a", "e", "i", "o", "u"].includes(noun.charAt(0)) ? "an" : "a";
    }
  }, {
    key: "addWidthDefinitions",
    value: function addWidthDefinitions(widthDefinitionObject) {
      var onDone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

      this._validateWidthDefinition(widthDefinitionObject, false);

      for (var _i2 = 0, _Object$entries2 = Object.entries(widthDefinitionObject); _i2 < _Object$entries2.length; _i2++) {
        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
            widthCategoryName = _Object$entries2$_i[0],
            screenWidthObject = _Object$entries2$_i[1];

        this.widthDefinitions[widthCategoryName] = screenWidthObject;
      }

      this._computeIsAndCallbacks();

      onDone();
    }
  }, {
    key: "setMainCallback",
    value: function setMainCallback(when, callback) {
      var onDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};
      var acceptableEvents = {
        widthchange: "onWidthChange",
        heightchange: "onHeightChange",
        bothchange: "onBothChange"
      };
      if (!Object.keys(acceptableEvents).includes(when)) throw "Error: The second parameter (when) has to be a string with a value of either \"widthchange\", \"heightchange\" or \"bothchange\". \"".concat(when, "\" was supplied");
      var eventName = acceptableEvents[when];

      var callbackType = _typeof(callback);

      if (callbackType !== "function") {
        throw this._typeErrorMessageBuilder("\"".concat(eventName, "\" for options"), "function", callbackType);
      }

      this[eventName] = function () {
        return callback();
      };

      this._computeIsAndCallbacks();

      onDone();
    }
  }, {
    key: "removeMainCallback",
    value: function removeMainCallback(when) {
      var onDone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
      var acceptableEvents = {
        widthchange: "onWidthChange",
        heightchange: "onHeightChange",
        bothchange: "onBothChange"
      };
      if (!Object.keys(acceptableEvents).includes(when)) throw "Error: The first parameter (when) has to be a string with a value of either \"widthchange\", \"heightchange\" or \"bothchange\". \"".concat(when, "\" was supplied");
      var eventName = acceptableEvents[when];

      this[eventName] = function () {};

      onDone();
    }
  }, {
    key: "_validateWidthDefinition",
    value: function _validateWidthDefinition(obj) {
      var atInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var where = atInit ? "widthDefinition" : "the main object";
      if (_typeof(obj) !== "object") throw this._typeErrorMessageBuilder(atInit ? where : "The main object", "object", obj); // Required keys for a "widthDefinition" with array of acceptable "typeof"s

      var requiredKeys = {
        min: ["number"],
        max: ["number"],
        inclusion: ["string"]
      };

      for (var _i3 = 0, _Object$entries3 = Object.entries(obj); _i3 < _Object$entries3.length; _i3++) {
        var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),
            widthCategoryName = _Object$entries3$_i[0],
            screenWidthObject = _Object$entries3$_i[1];

        if (_typeof(screenWidthObject) !== "object") throw this._typeErrorMessageBuilder("\"".concat(widthCategoryName, "\" inside ").concat(where), "object", screenWidthObject);
        var validObj = true;
        var screenWidthObjectKeys = Object.keys(screenWidthObject);

        for (var _i4 = 0, _Object$keys = Object.keys(requiredKeys); _i4 < _Object$keys.length; _i4++) {
          var acceptableKey = _Object$keys[_i4];

          if (!screenWidthObjectKeys.includes(acceptableKey)) {
            validObj = false;
          }
        }

        if (!validObj) {
          throw "Invalid ".concat(where, " for \"").concat(widthCategoryName, "\" due to missing required object key(s). \"").concat(widthCategoryName, "\" has to be an object containing \"min\" (Number), \"max\" (Number) and \"inclusion\" (String)");
        }

        for (var _i5 = 0, _Object$entries4 = Object.entries(screenWidthObject); _i5 < _Object$entries4.length; _i5++) {
          var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i5], 2),
              key = _Object$entries4$_i[0],
              value = _Object$entries4$_i[1];

          var acceptableTypes = requiredKeys[key]; // Current key requires validation

          if (acceptableTypes && !acceptableTypes.includes(_typeof(value))) {
            throw this._typeErrorMessageBuilder("\"".concat(key, "\" for \"").concat(widthCategoryName, "\" inside ").concat(where), acceptableTypes.join(", or "), value);
          }

          if (screenWidthObject.min > screenWidthObject.max) {
            throw "Error: The value of \"min\" has to be equals to or less than the value of \"max\" for \"".concat(widthCategoryName, "\" inside ").concat(where);
          } else if (screenWidthObject.min > screenWidthObject.max) {
            throw "Error: The value of \"max\" has to be equals to or greater than the value of \"min\" for \"".concat(widthCategoryName, "\" inside ").concat(where);
          }

          if (key === "inclusion") {
            if (!this._isValidInclusion(value)) {
              throw "Error: Invalid inclusion provided for screen size \"".concat(widthCategoryName, "\". The only valid value is a string with the value \"[]\", \"()\", \"[)\" or \"()\"");
            }
          } // Optional whileInside, onEnter and onLeave functions. If supplied, they have to be a function


          var optionalCallbackFunctions = ["whileInside", "onEnter", "onLeave"];

          for (var _i6 = 0, _optionalCallbackFunc = optionalCallbackFunctions; _i6 < _optionalCallbackFunc.length; _i6++) {
            var callbackName = _optionalCallbackFunc[_i6];

            if (key === callbackName) {
              if (typeof value !== "function") {
                throw this._typeErrorMessageBuilder("\"".concat(key, "\" for \"").concat(widthCategoryName, "\" inside ").concat(where), "function if defined", value);
              }
            }
          }
        }
      }
    }
  }, {
    key: "removeWidthDefinition",
    value: function removeWidthDefinition(widthCategoryName) {
      var onDone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

      if (!this.widthDefinitions[widthCategoryName]) {
        throw "\"".concat(widthCategoryName, "\" is not found in \"widthDefinitions\" for removal");
      }

      delete this.widthDefinitions[widthCategoryName];
      onDone();
    }
  }, {
    key: "setWidthCategoryCallback",
    value: function setWidthCategoryCallback(widthCategoryName, when, callback) {
      var onDone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};

      if (!this.widthDefinitions[widthCategoryName]) {
        throw "Error: \"".concat(widthCategoryName, "\" is not found in \"widthDefinitions\". You need to define it first by using the \"defineWidth\" method");
      }

      var acceptableEvents = {
        enter: "onEnter",
        inside: "whileInside",
        leave: "onLeave"
      };
      if (!Object.keys(acceptableEvents).includes(when)) throw "Error: The second parameter (when) has to be a string with a value of either \"enter\", \"inside\" or \"leave\". \"".concat(when, "\" was supplied");
      var eventName = acceptableEvents[when];

      var callbackType = _typeof(callback);

      if (callbackType !== "function") {
        throw this._typeErrorMessageBuilder("\"".concat(eventName, "\" for \"").concat(widthCategoryName, "\" inside \"widthDefinitions\""), "function", callbackType);
      }

      this.widthDefinitions[widthCategoryName][eventName] = function () {
        return callback();
      };

      this._computeIsAndCallbacks();

      onDone();
    }
  }, {
    key: "removeWidthCategoryCallback",
    value: function removeWidthCategoryCallback(widthCategoryName, when) {
      var onDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};

      if (!this.widthDefinitions[widthCategoryName]) {
        throw "\"".concat(widthCategoryName, "\" is not found in \"widthDefinitions\" for callback removal");
      }

      var acceptableEvents = {
        enter: "onEnter",
        inside: "whileInside",
        leave: "onLeave"
      };
      if (!Object.keys(acceptableEvents).includes(when)) throw "Error: The second parameter (when) has to be a string with a value of either \"enter\", \"inside\" or \"leave\". \"".concat(when, "\" was supplied");
      var eventName = acceptableEvents[when];
      delete this.widthDefinitions[widthCategoryName][eventName];
      onDone();
    }
  }, {
    key: "_typeErrorMessageBuilder",
    value: function _typeErrorMessageBuilder(property, type, valueProvided) {
      var typeOfValueProvided = _typeof(valueProvided);

      return "Error: ".concat(property, " has to be ").concat(this._aOrAn(type), " ").concat(type, " but ").concat(this._aOrAn(typeOfValueProvided), " ").concat(typeOfValueProvided, " was provided");
    }
  }, {
    key: "_isValidInclusion",
    value: function _isValidInclusion(inclusion) {
      var validInclusionRegex = /^[\[\(]{1}[\]\)]{1}/;
      return validInclusionRegex.test(inclusion);
    }
  }, {
    key: "_isWidthIncluded",
    value: function _isWidthIncluded(screenSizeName, minWidth, maxWidth, inclusion) {
      if (!this._isValidInclusion(inclusion)) {
        throw "Error: Invalid inclusion provided for screen size \"".concat(screenSizeName, "\". The only valid combinations are \"[]\", \"()\", \"[)\" and \"()\"");
      }

      var includeStart = inclusion[0] == "[" ? true : false;
      var includeEnd = inclusion[1] == "]" ? true : false;
      var startPass = includeStart ? this.width >= minWidth : this.width > minWidth;
      var endPass = includeEnd ? this.width <= maxWidth : this.width < maxWidth;
      return startPass && endPass;
    }
  }, {
    key: "_isEmptyObject",
    value: function _isEmptyObject(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) return false;
      }

      return true;
    }
  }, {
    key: "_computeIsAndCallbacks",
    value: function _computeIsAndCallbacks() {
      for (var _i7 = 0, _Object$entries5 = Object.entries(this.widthDefinitions); _i7 < _Object$entries5.length; _i7++) {
        var _Object$entries5$_i = _slicedToArray(_Object$entries5[_i7], 2),
            name = _Object$entries5$_i[0],
            property = _Object$entries5$_i[1];

        var oldIs = this.is[name];

        var _isWidthIncluded = this._isWidthIncluded(name, property.min, property.max, property.inclusion);

        this.is[name] = _isWidthIncluded;

        if (_isWidthIncluded && this.widthDefinitions[name].whileInside) {
          this.widthDefinitions[name].whileInside(this);
        }

        if (oldIs === false && _isWidthIncluded && this.widthDefinitions[name].onEnter) {
          this.widthDefinitions[name].onEnter(this);
        }

        if (oldIs === true && !_isWidthIncluded && this.widthDefinitions[name].onLeave) {
          this.widthDefinitions[name].onLeave(this);
        }
      }
    }
  }, {
    key: "_resizeHandler",
    value: function _resizeHandler() {
      var oldWidth = this.width;
      var oldHeight = this.height;
      this.width = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
      this.height = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);

      this._computeIsAndCallbacks();

      if (oldWidth !== this.width && oldHeight === this.height) {
        this.onWidthChange(this);
      } else if (oldWidth === this.width && oldHeight !== this.height) {
        this.onHeightChange(this);
      } else if (oldWidth && oldHeight && this.width && this.height && oldWidth !== this.width && oldHeight !== this.height) {
        this.onBothChange(this);
      }
    }
  }]);

  return ScreenSizeDetector;
}();

module.exports = ScreenSizeDetector;